<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>文字麻将 - P2P联机版</title>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <style>
        :root { --mj-green: #1a472a; --tile-bg: #fff; --accent: #ffeb3b; }
        body { font-family: sans-serif; background: #111; color: white; margin: 0; padding: 10px; min-height: 100vh; display: flex; flex-direction: column; box-sizing: border-box; }
        
        /* 联机控制面板 */
        #conn-panel { background: #222; padding: 10px; border-radius: 8px; margin-bottom: 10px; border: 1px solid #444; }
        .id-text { color: var(--accent); font-weight: bold; font-family: monospace; font-size: 1.1rem; }
        
        #pool-area { height: 100px; background: rgba(255,255,255,0.05); border: 1px solid #333; border-radius: 5px; padding: 5px; display: flex; flex-wrap: wrap; align-content: flex-start; gap: 3px; overflow-y: auto; margin-bottom: 10px; }
        
        /* 对方区域（仅显示名字和弃牌提示） */
        .opponent-side { background: #1a1a1a; padding: 10px; border-radius: 8px; text-align: center; color: #666; font-size: 0.8rem; margin-bottom: 10px; border: 1px dashed #333; }
        .opponent-side.active { border: 1px solid var(--accent); color: var(--accent); }

        /* 自己区域 */
        .my-side { background: #222; border: 1px solid #444; padding: 10px; border-radius: 8px; flex: 1; display: flex; flex-direction: column; }
        .my-side.active { background: var(--mj-green); border-color: var(--accent); }

        .hand { display: flex; flex-wrap: wrap; gap: 5px; justify-content: center; margin: 15px 0; }
        .tile { width: 38px; height: 52px; background: var(--tile-bg); color: #000; border-radius: 4px; display: flex; align-items: center; justify-content: center; font-size: 1.2rem; font-weight: bold; box-shadow: 0 3px #ccc; border: 2px solid transparent; }
        .tile.selected { border-color: #2196f3; transform: translateY(-8px); }
        .tile.pool-tile { width: 25px; height: 35px; font-size: 0.8rem; box-shadow: 0 1px #999; }
        .tile.new { background: #fffde7; border-color: #ffa000; }

        .controls { display: flex; gap: 8px; }
        button { flex: 1; padding: 12px 0; border: none; border-radius: 6px; font-weight: bold; cursor: pointer; }
        .btn-draw { background: var(--accent); }
        .btn-discard { background: #2196f3; color: white; }
        .btn-win { background: #f44336; color: white; flex: 0.5; }
        input { padding: 8px; border-radius: 4px; border: 1px solid #444; background: #000; color: white; width: 120px; }

        /* 投票弹窗 */
        #vote-overlay { display: none; position: fixed; inset: 0; background: rgba(0,0,0,0.9); z-index: 1000; flex-direction: column; align-items: center; justify-content: center; text-align: center; }
        .vote-card { background: #333; padding: 25px; border-radius: 15px; border: 2px solid var(--accent); width: 85%; }
    </style>
</head>
<body>

    <div id="conn-panel">
        <div id="my-id-display">我的 ID: <span class="id-text" id="my-id">正在获取...</span></div>
        <div id="connect-tools" style="margin-top:8px;">
            <input type="text" id="peer-id-input" placeholder="输入对方ID">
            <button onclick="connectToPeer()" style="width:auto; padding:8px 15px; background:#444; color:white;">连接对手</button>
        </div>
        <div id="status-msg" style="font-size:0.7rem; color: #aaa; margin-top:5px;">等待连接...</div>
    </div>

    <div id="opponent-info" class="opponent-side">对手区域</div>

    <div id="pool-area"></div>

    <div id="my-zone" class="my-side">
        <div style="font-size:0.7rem; margin-bottom:5px;">我的手牌 (仅自己可见)</div>
        <div class="hand" id="my-hand"></div>
        <div class="controls">
            <button class="btn-draw" id="btn-draw" onclick="doDraw()" disabled>摸牌</button>
            <button class="btn-discard" id="btn-discard" onclick="doDiscard()" disabled>出牌/吃牌</button>
            <button class="btn-win" onclick="askWin()">胡牌</button>
        </div>
    </div>

    <div id="vote-overlay">
        <div class="vote-card">
            <h2 id="vote-title">胡牌申请</h2>
            <div id="vote-content" style="font-size:1.8rem; color:var(--accent); margin:20px 0;"></div>
            <div style="display:flex; gap:10px;">
                <button style="background:#4caf50; color:white; padding:15px; flex:1;" onclick="sendVote(true)">认可</button>
                <button style="background:#f44336; color:white; padding:15px; flex:1;" onclick="sendVote(false)">不认可</button>
            </div>
        </div>
    </div>

<script>
    const RAW_CHARS = "我你他她咱谁们大家的人的了是不都在有没要会想看听写讲说拿走跑去玩笑哭爱恨怕请问谢对起给打找买卖用开关就才又还也只很最真太快慢大中小多多少好坏美丑新旧长短高矮胖瘦黑白红绿蓝天地下山水花草鱼肉饭菜酒水车书笔纸钱家校友手足口眼头面心身东西".split("");
    let peer, conn;
    let myHand = [], discardPool = [], lastDiscard = null;
    let isMyTurn = false, hasActioned = false, firstIdx = -1, myRole = ''; // 'host' or 'guest'

    // 1. 初始化 Peer
    peer = new Peer();
    peer.on('open', id => { document.getElementById('my-id').innerText = id; });

    // 2. 房主等待连接
    peer.on('connection', c => {
        conn = c;
        myRole = 'host';
        setupConn();
        initGame(); // 房主负责生成初始牌堆并分发
    });

    // 3. 访客主动连接
    function connectToPeer() {
        const targetId = document.getElementById('peer-id-input').value;
        conn = peer.connect(targetId);
        myRole = 'guest';
        setupConn();
    }

    function setupConn() {
        document.getElementById('status-msg').innerText = "已连接对手！游戏开始。";
        document.getElementById('connect-tools').style.display = 'none';
        conn.on('data', data => handleData(data));
    }

    // 4. 核心逻辑：数据处理
    function handleData(data) {
        switch(data.type) {
            case 'INIT_GAME': // 接收初始牌
                myHand = data.hand;
                discardPool = data.pool;
                isMyTurn = (myRole === 'guest'); // 假设访客先手或房主先手，这里设房主先手
                isMyTurn = data.firstTurn === myRole;
                render();
                break;
            case 'OPPONENT_DISCARD':
                discardPool.push(data.tile);
                lastDiscard = data.tile;
                isMyTurn = true;
                hasActioned = false;
                render();
                break;
            case 'OPPONENT_DRAW':
                isMyTurn = false; // 仅更新显示
                render();
                break;
            case 'VOTE_WIN':
                document.getElementById('vote-content').innerText = data.sentence;
                document.getElementById('vote-overlay').style.display = 'flex';
                break;
            case 'VOTE_RESULT':
                if(data.agreed) { alert("对方认可了！你赢了！"); location.reload(); }
                else { alert("对方拒绝了你的胡牌。"); }
                break;
            case 'SYNC_POOL': // 同步牌堆数量等
                document.getElementById('status-msg').innerText = "对方已摸牌，牌堆剩 " + data.deckLeft;
                break;
        }
    }

    // 5. 游戏动作
    function initGame() {
        let deck = [];
        RAW_CHARS.forEach(c => { for(let i=0; i<2; i++) deck.push(c); });
        deck.sort(() => Math.random() - 0.5);
        
        const hostHand = deck.splice(0, 13);
        const guestHand = deck.splice(0, 13);
        
        myHand = hostHand;
        isMyTurn = true; 
        
        // 发送给访客
        conn.send({
            type: 'INIT_GAME',
            hand: guestHand,
            pool: [],
            firstTurn: 'host',
            fullDeck: deck // 房主维护主牌堆
        });
        window.mainDeck = deck; // 房主存本地
        render();
    }

    function doDraw() {
        // 请求摸牌（如果是房主直接摸，如果是访客发请求给房主）
        // 为了简化，房主直接发一张牌过去
        if(myRole === 'host') {
            const t = window.mainDeck.shift();
            myHand.push(t);
            hasActioned = true;
            lastDiscard = null;
            conn.send({ type: 'SYNC_POOL', deckLeft: window.mainDeck.length });
            render();
        } else {
            // 访客需要房主给牌，这里略去复杂请求，逻辑同上，实际建议房主统一管理
            // 简单演示：访客本地模拟摸牌，发指令同步
            // (实际生产环境需更严谨同步)
            conn.send({ type: 'REQUEST_DRAW' }); 
        }
    }
    
    // 房主处理访客摸牌请求
    // (在handleData里增加：case 'REQUEST_DRAW' -> 给访客发一张牌)

    function doDiscard() {
        if(!hasActioned) { // 吃牌逻辑
            if(!lastDiscard) return;
            myHand.push(lastDiscard);
            hasActioned = true;
            lastDiscard = null;
            render();
            return;
        }
        if(firstIdx === -1) return alert("选一张牌");
        const t = myHand.splice(firstIdx, 1)[0];
        discardPool.push(t);
        conn.send({ type: 'OPPONENT_DISCARD', tile: t });
        isMyTurn = false;
        hasActioned = false;
        firstIdx = -1;
        render();
    }

    function askWin() {
        if(myHand.length !== 13) return alert("必须13张牌成句");
        conn.send({ type: 'VOTE_WIN', sentence: myHand.join("") });
    }

    function sendVote(agreed) {
        document.getElementById('vote-overlay').style.display = 'none';
        conn.send({ type: 'VOTE_RESULT', agreed: agreed });
        if(agreed) location.reload();
    }

    function render() {
        const container = document.getElementById('my-hand');
        container.innerHTML = '';
        myHand.forEach((t, i) => {
            const el = document.createElement('div');
            el.className = `tile ${firstIdx === i ? 'selected' : ''}`;
            el.innerText = t;
            el.onclick = () => { if(isMyTurn) { handleSort(i); } };
            container.appendChild(el);
        });

        const pool = document.getElementById('pool-area');
        pool.innerHTML = '';
        discardPool.forEach(t => {
            const d = document.createElement('div');
            d.className = 'tile pool-tile'; d.innerText = t;
            pool.appendChild(d);
        });

        document.getElementById('my-zone').className = `my-side ${isMyTurn ? 'active' : ''}`;
        document.getElementById('opponent-info').className = `opponent-side ${!isMyTurn ? 'active' : ''}`;
        document.getElementById('opponent-info').innerText = isMyTurn ? "对手等待中..." : "对手正在操作...";
        
        document.getElementById('btn-draw').disabled = (!isMyTurn || hasActioned);
        document.getElementById('btn-discard').disabled = (!isMyTurn);
    }

    function handleSort(idx) {
        if(firstIdx === -1) firstIdx = idx;
        else if(firstIdx === idx) firstIdx = -1;
        else {
            const item = myHand.splice(firstIdx, 1)[0];
            myHand.splice(idx, 0, item);
            firstIdx = -1;
        }
        render();
    }
</script>
</body>
</html>
